<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cartoon Mini Shooter v4 ‚Äî Animated Edition</title>
<style>
  :root{--ui-bg:#0b3a5b;--panel:#e6f6ff}
  html,body{height:100%;margin:0;background:linear-gradient(#071521,#08162b);font-family:Inter,system-ui,Arial;color:#fff;display:flex;align-items:center;justify-content:center}
  #wrap{width:1000px;max-width:98vw;background:linear-gradient(180deg,#aee7ff,#8fd7ff);border-radius:16px;padding:12px;box-shadow:0 20px 60px rgba(2,6,23,.35)}
  .topbar{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;color:#04324a;font-weight:700}
  .controls{display:flex;gap:8px;align-items:center}
  button, select{appearance:none;border:0;background:#ffd166;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700}
  .icon-btn{background:#fff;padding:6px;border-radius:10px;border:1px solid rgba(0,0,0,.06);cursor:pointer}
  #game-area{position:relative}
  canvas{display:block;border-radius:10px;width:100%;height:640px;background:transparent}
  #overlayUI{position:absolute;left:12px;top:12px;z-index:5;pointer-events:none}
  #hud{display:flex;gap:18px;align-items:center;pointer-events:auto}
  .hearts{font-size:18px}
  .score{font-weight:900;font-size:18px}
  #startRow{display:flex;gap:8px;align-items:center}
  #loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:linear-gradient(rgba(2,6,23,0.6),rgba(2,6,23,0.6));border-radius:10px;z-index:10}
  .progress{width:60%;height:12px;background:rgba(255,255,255,0.12);border-radius:8px;overflow:hidden}
  .bar{height:100%;width:0%;background:linear-gradient(90deg,#7ee7c5,#6bc1ff)}
  .small{font-size:12px;color:#074056}
  #fsBtn{background:#8fd7ff}
  /* small responsive */
  @media (max-width:720px){ canvas{height:520px} }
</style>
</head>
<body>
<div id="wrap">
  <div class="topbar">
    <div style="display:flex;gap:14px;align-items:center">
      <div style="font-weight:900">Cartoon Mini Shooter ‚Äî v4</div>
      <div class="small">Animated Edition</div>
    </div>
    <div class="controls" id="startRow">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="hearts" id="hearts">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <select id="charSel" title="Character">
        <option value="boy">Boy</option>
        <option value="girl">Girl</option>
        <option value="robot">Robot</option>
      </select>
      <select id="bgSel" title="Background">
        <option value="sky">Sky</option>
        <option value="night">Night</option>
        <option value="space">Space</option>
      </select>
      <button id="startBtn">Start / Restart</button>
      <button id="fsBtn" class="icon-btn">Fullscreen</button>
    </div>
  </div>

  <div id="game-area">
    <canvas id="game" width="960" height="640"></canvas>
    <div id="loading">
      <div style="font-weight:800;font-size:20px;margin-bottom:12px">Loading Animated Edition...</div>
      <div class="progress"><div class="bar" id="bar"></div></div>
      <div style="margin-top:10px" class="small">Click Start to initialize audio & play</div>
    </div>
    <div id="overlayUI" style="left:18px;top:18px"></div>
  </div>
</div>

<script>
/* Cartoon Mini Shooter v4 - Animated Edition
   - Smooth character animations (bounce/tilt)
   - Bullet trails & glow
   - Enemy entry animation + particle explosions
   - Animated backgrounds: drifting clouds / twinkling stars / moving nebula
   - Floating "+10" score popups
   - Boss incoming warning and boss fight
   - Fullscreen button & audio init
   - Spacebar + Click shooting
*/

// Canvas setup
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener('resize', resize);
resize();

// UI
const loading = document.getElementById('loading');
const bar = document.getElementById('bar');
const startBtn = document.getElementById('startBtn');
const fsBtn = document.getElementById('fsBtn');
const charSel = document.getElementById('charSel');
const bgSel = document.getElementById('bgSel');
const scoreEl = document.getElementById('score');
const heartsEl = document.getElementById('hearts');

let audioCtx = null, musicGain = null, intenseGain = null;
function ensureAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  musicGain = audioCtx.createGain(); musicGain.gain.value = 0.12; musicGain.connect(audioCtx.destination);
  intenseGain = audioCtx.createGain(); intenseGain.gain.value = 0; intenseGain.connect(audioCtx.destination);
  startMusic();
}
function startMusic(){
  if(!audioCtx) return;
  // low base drone
  const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.value = 110;
  const g = audioCtx.createGain(); g.gain.value = 0.01; o.connect(g); g.connect(musicGain); o.start();
  // repeating soft motif (simple scheduled notes)
  const notes = [220, 260, 330, 260];
  notes.forEach((n,i)=>{
    const s = audioCtx.createOscillator(); s.type='triangle'; s.frequency.value=n;
    const sg = audioCtx.createGain(); sg.gain.value = 0.007; s.connect(sg); sg.connect(musicGain);
    s.start(audioCtx.currentTime + i*0.6); s.stop(audioCtx.currentTime + i*0.6 + 0.55);
  });
  // intense layer
  const it = audioCtx.createOscillator(); it.type='sawtooth'; it.frequency.value=80; it.connect(intenseGain); it.start();
}
function playShootSound(){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(1000,audioCtx.currentTime);
    o.frequency.exponentialRampToValueAtTime(450,audioCtx.currentTime+0.08);
    const g = audioCtx.createGain(); g.gain.value=0.06; o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime+0.09);
  }catch(e){}
}
function playPop(){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(700,audioCtx.currentTime);
    o.frequency.exponentialRampToValueAtTime(260,audioCtx.currentTime+0.12);
    const g = audioCtx.createGain(); g.gain.value=0.045; o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime+0.14);
  }catch(e){}
}

// loading bar animation then hide
let load = 0;
const loadTicker = setInterval(()=>{
  load += Math.random()*12;
  bar.style.width = Math.min(100,load)+'%';
  if(load>=100){ clearInterval(loadTicker); setTimeout(()=>loading.style.display='none',350); }
},120);

// Game state
let keys = {}, playing=false, paused=false;
let player=null, bullets=[], enemies=[], particles=[], popups=[];
let score=0, hearts=5;
let bgMode='sky';
let frame=0;
let boss=null, bossActive=false, bossWarningTimer=0;

// visual config
const MAX_PARTICLES = 160;
const CLOUDS = []; const STARS=[]; const NEBULA=[];

// initialize drifting clouds/stars/nebula
function initBackground(){
  CLOUDS.length=0; STARS.length=0; NEBULA.length=0;
  for(let i=0;i<8;i++) CLOUDS.push({x:Math.random()*canvas.clientWidth, y:40+Math.random()*140, s:0.6+Math.random()*0.6, vx:0.2+Math.random()*0.6});
  for(let i=0;i<120;i++) STARS.push({x:Math.random()*canvas.clientWidth, y:Math.random()*canvas.clientHeight, r:Math.random()*1.8, twink:Math.random()*0.6});
  for(let i=0;i<6;i++) NEBULA.push({x:Math.random()*canvas.clientWidth, y:Math.random()*canvas.clientHeight, r:60+Math.random()*160, ox:Math.random()*2-1, oy:Math.random()*2-1});
}
initBackground();

// utility
function rnd(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function roundRect(x,y,w,h,r,fillStyle){
  ctx.fillStyle = fillStyle || ctx.fillStyle;
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill();
}

// Player class with smooth animation
class Player{
  constructor(type){
    this.type = type || 'boy';
    this.w = 48; this.h = 56;
    this.x = (canvas.clientWidth/2)-this.w/2;
    this.y = canvas.clientHeight - this.h - 24;
    this.vx = 0; this.speed = 6;
    this.cooldown = 0;
    this.bounce = 0; // for smooth bob
  }
  move(){
    const left = keys['ArrowLeft'] || keys['a'];
    const right = keys['ArrowRight'] || keys['d'];
    if(left) this.vx = -this.speed;
    else if(right) this.vx = this.speed;
    else this.vx = 0;
    this.x += this.vx;
    this.x = clamp(this.x, 8, canvas.clientWidth - this.w - 8);
    // bouncing effect
    this.bounce += ( (this.vx!==0 ? -6 : 0) - this.bounce ) * 0.08;
    this.cooldown = Math.max(0, this.cooldown-1);
  }
  draw(){
    const x = this.x, y = this.y;
    // shadow
    ctx.save(); ctx.globalAlpha = 0.12; ctx.fillStyle='#000'; ctx.beginPath(); ctx.ellipse(x+this.w/2, y+this.h+6, this.w*0.6, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
    // body with tilt/bounce
    ctx.save();
    const tilt = this.vx/20;
    ctx.translate(x+this.w/2, y+this.h/2 + this.bounce*0.6);
    ctx.rotate(tilt);
    // head
    if(this.type==='robot'){
      roundRect(-20,-24,40,34,6,'#cbd5e1'); // head
      roundRect(-16,10,12,18,4,'#94a3b8'); roundRect(4,10,12,18,4,'#94a3b8');
      ctx.fillStyle='#081e3d'; ctx.fillRect(-8,-12,6,6); ctx.fillRect(6,-12,6,6);
    } else {
      // head circle
      ctx.fillStyle = '#ffd6a5'; ctx.beginPath(); ctx.arc(0,-8,18,0,Math.PI*2); ctx.fill();
      // hair/accessory for girl
      if(this.type==='girl'){ ctx.fillStyle='#ff6b9a'; ctx.fillRect(-14,-22,28,8); }
      // body
      ctx.fillStyle = (this.type==='girl')? '#fca5a5':'#ffae00';
      roundRect(-16,6,32,30,8);
      // legs
      ctx.fillStyle = '#6c5b7b'; ctx.fillRect(-12,34,8,12); ctx.fillRect(4,34,8,12);
      // cute face
      ctx.fillStyle='#222'; ctx.beginPath(); ctx.arc(-6,-10,2.5,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(6,-10,2.5,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#8a4b2a'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,-4,6,0,Math.PI); ctx.stroke();
    }
    // hands (shoot animation)
    ctx.fillStyle = '#ffd6a5';
    if(this.cooldown>0){
      // thrust hands forward
      roundRect(20,8,10,6,4); roundRect(-30,8,10,6,4);
    } else {
      roundRect(18,12,10,6,4); roundRect(-28,12,10,6,4);
    }
    ctx.restore();
  }
  shoot(){
    if(this.cooldown>0) return;
    // double bullets
    bullets.push(new Bullet(this.x+10, this.y+12, -12));
    bullets.push(new Bullet(this.x+this.w-16, this.y+12, -12));
    this.cooldown = 12;
    playShootSound();
    // small muzzle particle
    for(let i=0;i<6;i++){
      particles.push(new Particle(this.x+this.w/2, this.y+8, rnd(-1.6,1.6), rnd(-3.2,-1.2), 18));
    }
  }
}

// Bullet with trail
class Bullet{
  constructor(x,y,vy){
    this.x=x; this.y=y; this.vy=vy; this.w=6; this.h=12; this.trail = [];
  }
  update(){
    this.trail.push({x:this.x+this.w/2,y:this.y+this.h/2,life:22});
    if(this.trail.length>8) this.trail.shift();
    this.y += this.vy;
  }
  draw(){
    // trail
    for(let i=0;i<this.trail.length;i++){
      const t = this.trail[i];
      const a = i/this.trail.length;
      ctx.globalAlpha = 0.35 * (1-a);
      ctx.fillStyle = 'orange';
      ctx.beginPath(); ctx.ellipse(t.x, t.y + (i*0.6), 4*(1-a), 6*(1-a), 0, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;
    // core
    roundRect(this.x, this.y, this.w, this.h, 3, '#ff8a00');
    // glow
    ctx.save(); ctx.globalAlpha = 0.18; ctx.fillStyle = '#ffb86b'; ctx.beginPath(); ctx.ellipse(this.x+this.w/2, this.y+6, 14, 6, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
  }
}

// Enemy with entry animation
class Enemy{
  constructor(x,y,speed){
    this.x = x; this.y = y; this.speed = speed; this.w=40; this.h=36;
    this.vy = 0; this.state='enter'; this.enterTargetY = 60 + Math.random()*80;
    this.hp = 1;
  }
  update(){
    if(this.state==='enter'){
      this.vy += 0.06;
      this.y += this.vy;
      if(this.y >= this.enterTargetY){ this.y = this.enterTargetY; this.state='live'; this.vy = 0; // smoke particles
        for(let i=0;i<6;i++) particles.push(new Particle(this.x+this.w/2,this.y+this.h, rnd(-1.8,1.8), rnd(-2.6,-0.6), 22));
      }
    } else {
      this.y += this.speed + Math.sin(frame/40 + this.x)*0.3;
      this.x += Math.sin(frame/60 + this.y/80)*0.6;
    }
  }
  draw(){
    ctx.save();
    // little bounce
    const bob = Math.sin((frame + this.x)/20)*2;
    roundRect(this.x, this.y + bob, this.w, this.h, 8, '#9ad3bc');
    ctx.fillStyle = '#05386B'; ctx.beginPath(); ctx.arc(this.x+12, this.y+12 + bob, 3.8, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(this.x+28, this.y+12 + bob, 3.8, 0, Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

// Particle for explosions / smoke
class Particle{
  constructor(x,y,dx,dy,life){
    this.x=x; this.y=y; this.dx=dx; this.dy=dy; this.life=life;
    this.size = 2 + Math.random()*3;
  }
  update(){
    this.x += this.dx; this.y += this.dy; this.dy += 0.06; this.life--;
  }
  draw(){
    ctx.globalAlpha = clamp(this.life/20,0,1);
    ctx.fillStyle = '#ff6b6b';
    ctx.fillRect(this.x, this.y, this.size, this.size);
    ctx.globalAlpha = 1;
  }
}

// Floating score popup
class Popup{
  constructor(x,y,text){
    this.x=x; this.y=y; this.text=text; this.life=60;
  }
  update(){ this.y -= 0.6; this.life--; }
  draw(){
    ctx.globalAlpha = clamp(this.life/60,0,1);
    ctx.font = '16px bold Arial'; ctx.fillStyle = '#fff'; ctx.fillText(this.text, this.x, this.y);
    ctx.globalAlpha = 1;
  }
}

// Boss
class Boss{
  constructor(){
    this.w = 220; this.h=120; this.x = (canvas.clientWidth - this.w)/2; this.y = -200;
    this.hp = 80; this.state='enter'; this.timer=0;
  }
  update(){
    if(this.state==='enter'){ this.y += 1.4; if(this.y>=80) this.state='fight'; }
    else{ this.timer++; // horizontal sweep
      this.x += Math.sin(this.timer/60)*2.4;
      if(this.timer%80===0){ // fire mini lasers as enemies
        const laserX = this.x + 40 + Math.random()*(this.w - 80);
        enemies.push(new Enemy(laserX, this.y + this.h - 8, 4));
      }
    }
  }
  draw(){
    roundRect(this.x, this.y, this.w, this.h, 16, '#ffcc99');
    // face details
    ctx.fillStyle = '#8a4b2a'; ctx.fillRect(this.x+36, this.y+28, 28, 12); ctx.fillRect(this.x+156, this.y+28, 28, 12);
    // hp bar
    const barX = this.x+12, barY = this.y - 18, barW = this.w - 24;
    roundRect(barX,barY,barW,12,6,'rgba(0,0,0,0.18)');
    roundRect(barX+4,barY+2, (barW-8)*(this.hp/80),8,4,'#ff6b6b');
  }
}

// init
function resetGame(){
  bullets.length=0; enemies.length=0; particles.length=0; popups.length=0;
  player = new Player(charSel.value);
  score = 0; hearts = 5; updateHUD();
  boss = null; bossActive=false; frame=0;
  initBackground();
}
resetGame();

// HUD update
function updateHUD(){
  scoreEl.textContent = Math.floor(score);
  heartsEl.innerHTML = '';
  for(let i=0;i<5;i++){ heartsEl.innerHTML += (i<hearts)?'‚ù§Ô∏è':'ü§ç'; }
}

// spawn enemy ticks
function maybeSpawn(){
  if(bossActive) return;
  if(Math.random() < 0.03 + Math.min(0.12, score/2000)){
    const x = rnd(40, canvas.clientWidth - 80);
    const e = new Enemy(x, -80, 1.2 + Math.random()*1.6);
    enemies.push(e);
  }
}

// input
window.addEventListener('keydown', e=>{ keys[e.key]=true; if(e.code==='Space'){ e.preventDefault(); if(playing) player.shoot(); }});
window.addEventListener('keyup', e=>{ keys[e.key]=false; });
canvas.addEventListener('click', ()=>{ if(playing) player.shoot(); });

// fullscreen
fsBtn.addEventListener('click', ()=>{
  if(!document.fullscreenElement) document.documentElement.requestFullscreen();
  else document.exitFullscreen();
});

// Start button
startBtn.addEventListener('click', ()=>{
  ensureAudio();
  loading.style.display='none';
  resetGame();
  playing = true;
});

// draw animated background
function drawBackground(){
  if(bgSel.value==='sky'){
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
    g.addColorStop(0,'#c6f3ff'); g.addColorStop(1,'#e6fbff');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    // clouds drift
    CLOUDS.forEach(c=>{
      c.x += c.vx * 0.4;
      if(c.x > canvas.clientWidth + 80) c.x = -120;
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = '#ffffff';
      const s = c.s;
      ellipse(c.x, c.y, 40*s, 26*s); ellipse(c.x+30*s, c.y+6, 34*s, 24*s); ellipse(c.x-28*s, c.y+4, 30*s, 18*s);
      ctx.globalAlpha = 1;
    });
  } else if(bgSel.value==='night'){
    ctx.fillStyle = '#071430'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    STARS.forEach(s=>{
      // twinkle
      const tw = Math.sin((frame + s.x + s.y)*0.05) * 0.5 + 0.5;
      ctx.globalAlpha = tw * (s.twink+0.3);
      ctx.fillStyle = '#ffffff'; ctx.fillRect((s.x+frame*0.1)%canvas.clientWidth, s.y, s.r, s.r);
      ctx.globalAlpha = 1;
    });
  } else {
    ctx.fillStyle = '#000014'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    NEBULA.forEach(n=>{
      n.x += n.ox * 0.2; n.y += n.oy * 0.15;
      if(n.x < -200) n.x = canvas.clientWidth + 200;
      ctx.globalAlpha = 0.08;
      const rg = ctx.createRadialGradient(n.x, n.y, 10, n.x, n.y, n.r);
      rg.addColorStop(0,'#8fb6ff'); rg.addColorStop(1,'transparent');
      ctx.fillStyle = rg; ctx.fillRect(n.x - n.r, n.y - n.r, n.r*2, n.r*2);
      ctx.globalAlpha = 1;
    });
    // stars
    STARS.forEach(s=>{ ctx.fillStyle = '#fff'; ctx.fillRect((s.x+frame*0.1)%canvas.clientWidth, s.y, s.r, s.r); });
  }
}

// main loop
function loop(){
  frame++;
  // Update
  if(playing && !paused){
    player.move();
    // bullets
    for(let i=bullets.length-1;i>=0;i--){
      bullets[i].update();
      if(bullets[i].y < -30) bullets.splice(i,1);
    }
    // enemies
    for(let i=enemies.length-1;i>=0;i--){
      enemies[i].update();
      if(enemies[i].y > canvas.clientHeight + 80) enemies.splice(i,1);
    }
    // particles
    for(let i=particles.length-1;i>=0;i--){
      particles[i].update();
      if(particles[i].life <= 0) particles.splice(i,1);
    }
    // popups
    for(let i=popups.length-1;i>=0;i--){ popups[i].update(); if(popups[i].life<=0) popups.splice(i,1); }
    // collisions: bullets vs enemies
    for(let bi=bullets.length-1;bi>=0;bi--){
      const b = bullets[bi];
      for(let ei=enemies.length-1;ei>=0;ei--){
        const e = enemies[ei];
        if(b.x < e.x + e.w && b.x + b.w > e.x && b.y < e.y + e.h && b.y + b.h > e.y){
          // hit
          bullets.splice(bi,1);
          e.hp -= 1;
          score += 10;
          popups.push(new Popup(e.x + e.w/2, e.y, "+10"));
          // small explosion
          for(let p=0;p<8;p++){
            particles.push(new Particle(b.x + rnd(-6,6), b.y + rnd(-6,6), rnd(-2.4,2.4), rnd(-3.2,-0.6), 20));
          }
          playPop();
          if(e.hp <= 0){
            enemies.splice(ei,1);
            // bigger explosion
            for(let p=0;p<22;p++){
              if(particles.length < MAX_PARTICLES) particles.push(new Particle(e.x + rnd(0,e.w), e.y + rnd(0,e.h), rnd(-3.6,3.6), rnd(-4,1), 28));
            }
          }
          break;
        }
      }
      // bullets vs boss
      if(bossActive && boss && b){
        if(b.x > boss.x && b.x < boss.x + boss.w && b.y > boss.y && b.y < boss.y + boss.h){
          bullets.splice(bi,1); boss.hp -= 1; score += 2; popups.push(new Popup(b.x, b.y, "+2"));
          if(boss.hp <= 0){
            // boss defeated
            bossActive = false; boss = null;
            for(let p=0;p<80;p++) if(particles.length < MAX_PARTICLES) particles.push(new Particle(canvas.clientWidth/2 + rnd(-100,100), canvas.clientHeight/2 + rnd(-60,60), rnd(-6,6), rnd(-6,6), 40));
            score += 200; setTimeout(()=>{ popups.push(new Popup(canvas.clientWidth/2, canvas.clientHeight/2, "VICTORY!")); },300);
            playPop(); // victory sound effect
          }
        }
      }
    }
    // enemies hit player
    for(let ei=enemies.length-1;ei>=0;ei--){
      const e = enemies[ei];
      if(e.x < player.x + player.w && e.x + e.w > player.x && e.y < player.y + player.h && e.y + e.h > player.y){
        // collision
        enemies.splice(ei,1);
        hearts -= 1;
        updateHUD();
        // heart pop particles
        for(let p=0;p<14;p++) particles.push(new Particle(player.x + player.w/2, player.y + 8, rnd(-3,3), rnd(-6,-1), 26));
        playPop();
        if(hearts <= 0){ gameOver(); }
      }
    }
    // spawn
    maybeSpawn();
    // boss spawn threshold
    if(!bossActive && score > 350){
      bossActive = true; boss = new Boss();
      // warning popup
      bossWarningTimer = 180;
      popups.push(new Popup(canvas.clientWidth/2 - 40, 120, "BOSS INCOMING!"));
    }
    if(bossActive && boss){ boss.update(); }
    // update audio intensity
    if(audioCtx){
      const intensity = clamp((enemies.length/6) + (bossActive?0.8:0), 0, 1);
      intenseGain.gain.linearRampToValueAtTime(intensity * 0.08, audioCtx.currentTime + 0.08);
    }
  }

  // DRAW
  // background based on bgSel
  drawBackground();

  // ground & subtle vignette
  ctx.fillStyle = 'rgba(0,0,0,0.02)'; ctx.fillRect(0, canvas.clientHeight - 8, canvas.clientWidth, 8);

  // draw entities
  enemies.forEach(e=>e.draw());
  bullets.forEach(b=>b.draw());
  player.draw();
  particles.forEach(p=>p.draw());
  if(bossActive && boss) boss.draw();
  popups.forEach(p=>p.draw());

  // HUD floating hints
  ctx.fillStyle = 'rgba(5,56,107,0.06)'; if(!playing) roundRect(0, canvas.clientHeight/2 - 48, canvas.clientWidth, 96, 0);
  if(!playing){
    ctx.fillStyle='#05386B'; ctx.font='20px system-ui'; ctx.textAlign='center'; ctx.fillText('Click Start to play ‚Äî choose character & background', canvas.clientWidth/2, canvas.clientHeight/2 + 6);
  }

  // frame increment + HUD update
  frame++;
  updateHUD();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// helper: create bullet on space or click already wired in player.shoot
document.addEventListener('keydown', e=>{
  if(e.code === 'Space'){ if(playing) player.shoot(); e.preventDefault(); }
  if(e.key === 'p') paused = !paused;
});

// game over
function gameOver(){
  playing = false;
  // fade music
  if(audioCtx){ musicGain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 1.2); intenseGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3); }
  setTimeout(()=>{ popups.push(new Popup(canvas.clientWidth/2 - 40, canvas.clientHeight/2, "GAME OVER")); },120);
  // overlay draw handled by loop since playing false
}

// utility draw helpers
function ellipse(x,y,rx,ry){ ctx.beginPath(); ctx.ellipse(x,y,rx,ry,0,0,Math.PI*2); ctx.fill(); }
function roundRect(x,y,w,h,r,fill){ if(fill) ctx.fillStyle = fill; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }

// small background effects for sky/night/space using bgSel
function drawBackground(){
  const mode = bgSel.value;
  if(mode === 'sky'){
    const g = ctx.createLinearGradient(0,0,0,canvas.clientHeight);
    g.addColorStop(0,'#c6f3ff'); g.addColorStop(1,'#e6fbff');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    CLOUDS.forEach(c=>{
      c.x += c.vx * 0.5;
      if(c.x > canvas.clientWidth + 200) c.x = -200;
      ctx.globalAlpha = 0.96;
      ctx.fillStyle = '#fff';
      ellipse(c.x, c.y, 40*c.s, 24*c.s); ellipse(c.x+30*c.s, c.y+5*c.s, 32*c.s, 20*c.s); ellipse(c.x-30*c.s, c.y+4*c.s, 24*c.s, 16*c.s);
      ctx.globalAlpha = 1;
    });
  } else if(mode === 'night'){
    ctx.fillStyle = '#071430'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    STARS.forEach(s=>{
      const tw = Math.sin((frame + s.x + s.y)*0.05) * 0.5 + 0.5;
      ctx.globalAlpha = tw * (s.twink + 0.4);
      ctx.fillStyle = '#fff';
      ctx.fillRect((s.x + frame*0.06) % canvas.clientWidth, s.y, s.r, s.r);
    });
    ctx.globalAlpha = 1;
  } else {
    ctx.fillStyle = '#02021a'; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
    NEBULA.forEach(n=>{
      n.x += n.ox * 0.2; n.y += n.oy * 0.08;
      if(n.x < -200) n.x = canvas.clientWidth + 200;
      ctx.globalAlpha = 0.08;
      const rg = ctx.createRadialGradient(n.x, n.y, 10, n.x, n.y, n.r);
      rg.addColorStop(0,'#7fb7ff'); rg.addColorStop(1,'transparent');
      ctx.fillStyle = rg; ctx.fillRect(n.x - n.r, n.y - n.r, n.r*2, n.r*2);
      ctx.globalAlpha = 1;
    });
    STARS.forEach(s=> ctx.fillRect((s.x + frame*0.06)%canvas.clientWidth, s.y, s.r, s.r));
  }
}

// spawn loop ticker
setInterval(maybeSpawn, 600);

// small helper to limit heavy work on low devices
function safePushParticle(p){
  if(particles.length < MAX_PARTICLES) particles.push(p);
}

// responsive init: auto-fit player when selecting character or background
charSel.addEventListener('change', ()=>{ if(player) player.type = charSel.value; });
bgSel.addEventListener('change', ()=>{ /* immediate visual change occurs in loop */ });

// ensure initial sizing and start invisible loading removed after small delay
setTimeout(()=>{ loading.style.display='none'; }, 900);

</script>
</body>
</html>
